# 2413: 1st Exam Review
 
## [Part I. C++](https://github.com/omen0x8/CS2413-Exam1Review/tree/main/Part%201)

### 1. Can read C++ code and understand commonly used C++ syntax, including

- cin, cout

- variable declaration, variable assignment

- pointer, extract variable address, access data through pointer, access array elements through pointer

- array and vector declaration and element access

- basic vector operations such as ‘pushback’, ‘size’, ‘insert’.

- dynamic memory allocation: new int and new int[5]

- function definition, argument passing (by value and by reference), function declaration, calling a function – class definition, private and public member declaration, member function definition (prefix)

- class object declaration, object member access (through object name and class pointer)

### 2. Can read C++ code of a function and understand the function of the function.

### 3. Can write small pieces of code or pseudo-code using C++ syntax with no significant error

- to implement lectured algorithms

- to implement some new functions


## [Part II. Big O Notation](https://github.com/omen0x8/CS2413-Exam1Review/tree/main/Part%202)

### 1. Understand the meaning of big O notation (will not test math definition)

### 2. Know how to write down the big O term of a formula

### 3. Understand how to compare efficiency based on big O terms

### 4. Understand the difference between big O time/space complexity and exact time/space


## [Part III. Time Complexity and Space Complexity](https://github.com/omen0x8/CS2413-Exam1Review/tree/main/Part%203)

### 1. Know how to identify the best-case scenario and worst-case scenario when measuring time complexity

### 2. Know how to derive big O time/space complexity for a given (simple) C++ code or pseudo-code


## [Part IV. Search Algorithms (based on array/vector)](https://github.com/omen0x8/CS2413-Exam1Review/tree/main/Part%204)

### 1. Know how linear search and binary search work

- Given a list and a search key, can identify the search sequence

### 2. Know the time complexity of linear search and binary search and know how to briefly justify it (in particular, why is there a log2 n in the time complexity of binary search)

### 3. Know the space complexity of linear search and binary search based on the lectured pseudo-code (Table in the Lectured Slides on Sep 26) and how to briefly justify it


## [Part V. Sorting Algorithms (based on array/vector)](https://github.com/omen0x8/CS2413-Exam1Review/tree/main/Part%205)

### 1. Bubble Sort, Insertion Sort, Selection Sort
- Know how each algorithm works
- Given a list, can show the partially sorted list after k rounds of sorting.
- Know the time/space complexity of each algorithm and how to briefly justify it
- Know one way to implement each algorithm (in particular, how to address the technical challenges)
### 2. Merge Sort
- Know how it works
- Know how to implement a function that merge two sorted lists into one sorted list
- Know the time complexity and how to briefly justify it e.g., why there is a log2 n or why there is an n.
- Know the space complexity and how to briefly justify it e.g., why there is a log2 n or under what assumption will we have an extra n in the big O.
### 3. Quick Sort
- Know how it works
- Know how to implement a function that splits a list into two ordered sublists
- Know the time complexity in the best case and understand what is the best case scenario
- Know the time complexity in the worst case and understand what is the worst case scenario
### 4. Bucket Sort
- Know how it works
- Know how to best design the buckets; also know worst design of the buckets
- Know how to evaluate time complexity based on different subroutines applied on the buckets
- Know how to evaluate space complexity based on different subroutines applied on the buckets
### 6. Counting Sort
- Know how it works (at least the lectured algorithm)
- Given an input list, can elaborate newly created vectors.
- Know the time complexity and how to briefly justify it e.g., why there is an n or K (max value in the list).
- Know the space complexity and how to briefly justify it (based on a given implementation)
### 7. Radix Sort
- Know how it works (its subroutine)
- Given an input list, can show the partially sorted list after K bits are sorted
- Know how to implement Radix Sort, especially
- how to count the number of bits of the elements – how to extract a particular bit of the elements
- Know the time complexity and how to briefly justify it
- Know the space complexity and how to briefly justify it
- Understand the complexity depends on the complexity of the subroutine algorithm
